create table
  public.games (
    id bigint generated by default as identity not null,
    created_at timestamp with time zone null default now(),
    creator uuid null default auth.uid (),
    name text not null default 'New Game'::text,
    playercount smallint not null default '4'::smallint,
    gamefields array not null default '{cardcount}'::text[],
    playerfields array null default '{cardcount}'::text[],
    official boolean not null default false,
    init jsonb not null,
    deckcount smallint not null default '1'::smallint,
    constraint games_pkey primary key (id),
    constraint games_creator_fkey foreign key (creator) references auth.users (id) on delete set null,
    constraint games_deckcount_check check ((deckcount > 0)),
    constraint games_name_check check ((length(name) < 30)),
    constraint games_playercount_check check ((playercount > 1))
  ) tablespace pg_default;

create table
  public.session (
    id bigint generated by default as identity not null,
    created_at timestamp with time zone null default now(),
    table jsonb null,
    owner uuid not null default auth.uid (),
    game bigint null,
    started boolean not null default false,
    public boolean not null default false,
    constraint session_pkey primary key (id),
    constraint session_game_fkey foreign key (game) references games (id) on delete cascade,
    constraint session_owner_fkey foreign key (owner) references auth.users (id) on delete cascade
  ) tablespace pg_default;

create table
  public.session_players (
    id bigint generated by default as identity not null,
    session_id bigint not null,
    user_id uuid null default auth.uid (),
    hand jsonb null,
    name text not null default 'New Player'::text,
    constraint session_players_pkey primary key (id),
    constraint session_players_user_id_key unique (user_id),
    constraint session_players_session_id_fkey foreign key (session_id) references session (id) on delete cascade,
    constraint session_players_user_id_fkey foreign key (user_id) references auth.users (id) on delete cascade,
    constraint session_players_name_check check ((length(name) < 20))
  ) tablespace pg_default;

create table
  public.actions (
    id bigint generated by default as identity not null,
    left_field smallint null,
    action text null,
    right_field smallint null,
    number integer null,
    left_player smallint null,
    right_player smallint null,
    action_type smallint null,
    operator text null,
    left_value integer null,
    right_value integer null,
    left text null,
    right text null,
    constraint actions_pkey primary key (id),
    constraint actions_action_check check ((length(action) < 36)),
    constraint actions_left_check check ((length("left") < 11)),
    constraint actions_right_check check ((length("right") < 11))
  ) tablespace pg_default;

create table
  public.rules (
    id bigint generated by default as identity not null,
    created_at timestamp with time zone null default now(),
    operator text not null default '<'::text,
    left_field smallint null,
    right_field smallint null,
    left_player smallint null,
    right_player smallint null,
    right_value integer null,
    name text not null default 'New Rule'::text,
    action_id bigint null,
    left_value integer null,
    required boolean not null default true,
    or_bool boolean not null default false,
    exclusive smallint null,
    left text null,
    right text null,
    constraint rules_pkey primary key (id),
    constraint rules_action_id_fkey foreign key (action_id) references actions (id) on delete set null,
    constraint rules_left_check check ((length("left") < 11)),
    constraint rules_name_check check ((length(name) < 50)),
    constraint rules_operator_check check ((length(operator) < 25)),
    constraint rules_right_check check ((length("right") < 11))
  ) tablespace pg_default;

create table
  public.games_rules (
    id bigint generated by default as identity not null,
    game_id bigint null,
    rule_id bigint null,
    constraint games_rules_pkey primary key (id),
    constraint games_rules_game_id_fkey foreign key (game_id) references games (id) on delete cascade,
    constraint games_rules_rule_id_fkey foreign key (rule_id) references rules (id) on delete cascade
  ) tablespace pg_default;

create table
  public.chains (
    id bigint generated by default as identity not null,
    games_id bigint not null,
    chain_start bigint not null,
    chain_end bigint not null,
    or_bool boolean not null default false,
    constraint chains_pkey primary key (id),
    constraint chains_chain_end_fkey foreign key (chain_end) references rules (id) on delete cascade,
    constraint chains_chain_start_fkey foreign key (chain_start) references rules (id) on delete cascade,
    constraint chains_games_id_fkey foreign key (games_id) references games (id) on delete cascade
  ) tablespace pg_default;

create table
  public.leaderboard (
    id bigint generated by default as identity not null,
    user_id uuid null,
    name text not null default 'Player'::text,
    wins integer not null default 1,
    game_id bigint null,
    constraint leaderboard_pkey primary key (id),
    constraint leaderboard_game_id_fkey foreign key (game_id) references games (id) on delete cascade,
    constraint leaderboard_user_id_fkey foreign key (user_id) references auth.users (id) on delete set null
  ) tablespace pg_default;

create table
  public.tables (
    id bigint generated by default as identity not null,
    session_id bigint not null,
    table jsonb null,
    constraint tables_pkey primary key (id),
    constraint tables_session_id_key unique (session_id),
    constraint tables_session_id_fkey foreign key (session_id) references session (id) on delete cascade
  ) tablespace pg_default;

create table
  public.tableview (
    id bigint generated by default as identity not null,
    session_id bigint not null,
    top jsonb not null,
    current bigint not null,
    next bigint not null,
    dir smallint not null default '1'::smallint,
    sorter integer not null default 52,
    constraint tableview_pkey primary key (id),
    constraint tableview_session_id_key unique (session_id),
    constraint tableview_current_fkey foreign key (current) references session_players (id) on delete cascade,
    constraint tableview_next_fkey foreign key (next) references session_players (id) on delete cascade,
    constraint tableview_session_id_fkey foreign key (session_id) references session (id) on delete cascade
  ) tablespace pg_default;

create table
  public.hands (
    id bigint generated by default as identity not null,
    session_players_id bigint not null,
    hand jsonb null,
    constraint hands_pkey primary key (id),
    constraint hands_session_players_id_key unique (session_players_id),
    constraint hands_session_players_id_fkey foreign key (session_players_id) references session_players (id) on delete cascade
  ) tablespace pg_default;

create table
  public.handview (
    id bigint generated by default as identity not null,
    session_players_id bigint not null,
    top jsonb not null,
    constraint handview_pkey primary key (id),
    constraint handview_session_players_id_key unique (session_players_id),
    constraint handview_session_players_id_fkey foreign key (session_players_id) references session_players (id) on delete cascade
  ) tablespace pg_default;

CREATE POLICY "Read access for authenticated users" ON "public"."games"
AS PERMISSIVE FOR SELECT
TO authenticated
USING (true);

CREATE POLICY "Enable insert for authenticated users" ON "public"."games"
AS PERMISSIVE FOR INSERT
TO authenticated

WITH CHECK ((official = false));

CREATE POLICY "Delete own" ON "public"."session"
AS PERMISSIVE FOR DELETE
TO public
USING ((EXISTS ( SELECT 1 FROM session session_1 WHERE (session_1.owner = auth.uid()))));

CREATE POLICY "Enable insert for authenticated users only" ON "public"."session"
AS PERMISSIVE FOR INSERT
TO authenticated

WITH CHECK (true);

CREATE POLICY "Enable read access for all users" ON "public"."session"
AS PERMISSIVE FOR SELECT
TO public
USING (true);

CREATE POLICY "Update own" ON "public"."session"
AS PERMISSIVE FOR UPDATE
TO public
USING ((EXISTS ( SELECT 1 FROM session session_1 WHERE (session_1.owner = auth.uid()))))
WITH CHECK ((EXISTS ( SELECT 1 FROM session session_1 WHERE (session_1.owner = auth.uid()))));

CREATE POLICY "Delete own if not owner" ON "public"."session_players"
AS PERMISSIVE FOR DELETE
TO public
USING ((NOT (EXISTS ( SELECT 1 FROM (session_players session_players_1 JOIN session s ON ((s.id = session_players_1.session_id))) WHERE ((session_players_1.user_id = auth.uid()) AND (s.owner = auth.uid()))))));

CREATE POLICY "Enable read access for all users" ON "public"."session_players"
AS PERMISSIVE FOR SELECT
TO public
USING (true);

CREATE POLICY "Only if ID exists and not started" ON "public"."session_players"
AS PERMISSIVE FOR INSERT
TO public

WITH CHECK ((EXISTS ( SELECT 1 FROM session WHERE ((session.started = false) AND (session.id = session_players.session_id) AND (session_players.user_id = auth.uid())))));

CREATE POLICY "Update own when not started" ON "public"."session_players"
AS PERMISSIVE FOR UPDATE
TO public
USING ((EXISTS ( SELECT 1 FROM session WHERE ((session.started = false) AND (session.id = session_players.session_id) AND (session_players.user_id = auth.uid())))))
WITH CHECK ((EXISTS ( SELECT 1 FROM session WHERE ((session.started = false) AND (session.id = session_players.session_id) AND (session_players.user_id = auth.uid())))));

CREATE POLICY "Enable insert for authenticated users only" ON "public"."actions"
AS PERMISSIVE FOR INSERT
TO authenticated

WITH CHECK (true);

CREATE POLICY "Enable read access for all users" ON "public"."actions"
AS PERMISSIVE FOR SELECT
TO public
USING (true);

CREATE POLICY "Update own" ON "public"."actions"
AS PERMISSIVE FOR UPDATE
TO public
USING ((EXISTS ( SELECT 1 FROM ((rules JOIN games_rules gr ON ((rules.id = gr.rule_id))) JOIN games ON ((gr.game_id = games.id))) WHERE ((rules.action_id = actions.id) AND (games.creator = auth.uid())))))
WITH CHECK ((EXISTS ( SELECT 1 FROM ((rules JOIN games_rules gr ON ((rules.id = gr.rule_id))) JOIN games ON ((gr.game_id = games.id))) WHERE ((rules.action_id = actions.id) AND (games.creator = auth.uid())))));

CREATE POLICY "Enable insert for authenticated users only" ON "public"."rules"
AS PERMISSIVE FOR INSERT
TO authenticated

WITH CHECK (true);

CREATE POLICY "Enable read access for all users" ON "public"."rules"
AS PERMISSIVE FOR SELECT
TO public
USING (true);

CREATE POLICY "Update own" ON "public"."rules"
AS PERMISSIVE FOR UPDATE
TO public
USING ((EXISTS ( SELECT 1 FROM ((rules rules_1 JOIN games_rules gr ON ((rules_1.id = gr.rule_id))) JOIN games ON ((gr.game_id = games.id))) WHERE (games.creator = auth.uid()))))
WITH CHECK ((EXISTS ( SELECT 1 FROM ((rules rules_1 JOIN games_rules gr ON ((rules_1.id = gr.rule_id))) JOIN games ON ((gr.game_id = games.id))) WHERE (games.creator = auth.uid()))));

CREATE POLICY "Delete own" ON "public"."games_rules"
AS PERMISSIVE FOR DELETE
TO public
USING ((EXISTS ( SELECT 1 FROM games WHERE ((games.id = games_rules.game_id) AND (games.creator = auth.uid())))));

CREATE POLICY "Enable read access for all users" ON "public"."games_rules"
AS PERMISSIVE FOR SELECT
TO public
USING (true);

CREATE POLICY "Delete own" ON "public"."chains"
AS PERMISSIVE FOR DELETE
TO public
USING ((EXISTS ( SELECT 1 FROM games WHERE ((games.id = chains.games_id) AND (games.creator = auth.uid())))));

CREATE POLICY "Enable read access for all users" ON "public"."chains"
AS PERMISSIVE FOR SELECT
TO public
USING (true);

CREATE POLICY "Insert if own game and rule is on game" ON "public"."chains"
AS PERMISSIVE FOR INSERT
TO public

WITH CHECK (((( SELECT 1 FROM ((rules JOIN games_rules gr ON ((rules.id = gr.rule_id))) JOIN games ON ((gr.game_id = games.id))) WHERE ((rules.id = chains.chain_start) AND (games.creator = auth.uid()))) + ( SELECT 1 FROM ((rules JOIN games_rules gr ON ((rules.id = gr.rule_id))) JOIN games ON ((gr.game_id = games.id))) WHERE ((rules.id = chains.chain_end) AND (games.creator = auth.uid())))) IS NOT NULL));

CREATE POLICY "Enable read access for all users" ON "public"."leaderboard"
AS PERMISSIVE FOR SELECT
TO public
USING (true);

CREATE POLICY "Read table they are at" ON "public"."tableview"
AS PERMISSIVE FOR SELECT
TO authenticated
USING ((EXISTS ( SELECT 1 FROM session_players WHERE ((session_players.session_id = tableview.session_id) AND (session_players.user_id = auth.uid())))));

CREATE POLICY "Read own hand" ON "public"."handview"
AS PERMISSIVE FOR SELECT
TO authenticated
USING ((EXISTS ( SELECT 1 FROM session_players WHERE ((session_players.id = handview.session_players_id) AND (session_players.user_id = auth.uid())))));
